Niniejszym przedstawiam interpreter języka funkcyjnego Radlang. Jest on wyposażony w leniwą ewaluację, pełną inferencję typów, kontrolę kindów, polimorficzne algebraiczne typy danych z głębokim pattern matchingiem oraz elegancką składnię. Typowanie jest silnie i statyczne. Język zawiera *ukończoną* semantykę typeclass (znaną jako interfaces), oraz w pełni działający typechecking i rekonstrukcję typów dla dowolnych wyrażeń, także tych klasowych. Klasy mogą po sobie dziedziczyć, a instancje (implementacje) mogą zawierać constrainty innych klas.

W folderze good zamieszczam dwa pliki: jeden ~statet.rdl~ który obrazuje dość ciężkie wykorzystanie typeclass. Implementuje on monady (i oczywiście odpowiedniki applicativów oraz endofunktory) ~StateT~, ~Option~, ~OptionT~, ~Id~ oraz ~IdT~ i przy ich pomocy liczy n-tą liczbę fibonacciego na ewaluatorze ~StateT (Pair Int Int) (OptionT Id)~. Drugim przykładem jest ~radlang-junior.rdl~ – jest to napisany w moim języku programowania interpreter języka programowania który z tego przedmiotu dostałby 6 punktów. Radlang Junior jest językiem dla odmiany imperatywnym z kontynuacyjną semantyką. Obsługuje on statyczne wiązanie zmiennych. Interpreter ten pokazuje prawdopodobnie wszystkie funkcjonalności mojego języka poza typeclassami (w tym konstrukcję stałopunktową w semantyce while!) i jest swego rodzaju dowodem na niezawodność i użyteczność radlanga. W pliku znajduje się parę przykładowych programów które pokazują jak mniej więcej wygląda junior.

W folderze bad w plikach obrazujących błędy runtime'u warto zobaczyć jak działa system podwójnego stack trace oraz jak język radzi sobie z nienazwanymi wyrażeniami jak lambdy czy częściowo zaaplikowane funkcje.

Aby zbudować i uruchomić interpreter wystarczy napisać ~stack run interpreter~. Program sam pobierze wszystkie zależności, co może potrwać chwilę.
