* radlang

Purely functional, lazy programming language featuring static type checking, type inference and general polymorphic types. Program in radlang is understood as valid expression.

Syntax highly inspired by Haskell and OCaml.

** Installation

Clone the repo

~git clone https://github.com/radrow/radlang.git~

cd into dir

~cd radlang~

build

~stack build~

install (locally)

~stack install~

** Execution

Radlang interpreter can be run in two modes: evaluation from file ~rdl program.rdl~ and interactive REPL ~rdli~.

** Examples

Polymorphism and higher order functions:

#+BEGIN_SRC haskell
let id := \x -> x;
    compose f g x : (~B -> ~C) -> (~A -> ~B) -> ~A -> ~C := f (g x)
in compose id id 42
#+END_SRC

Fibonacci:

#+BEGIN_SRC haskell
let fibo n : Int -> Int :=
  if eq n 0 then 0
  if eq n 1 then 1
  else plus (fibo (minus n 1)) (fibo (minus n 2))
in fibo 8
#+END_SRC

Linear Fibonacci:

#+BEGIN_SRC haskell
let fibo :=
  let fibo a b n :=
    if eq n 0 then a
    else fibo b (plus a b) (minus n 1)
  in fibo 0 1
in fibo 4242
#+END_SRC

Fixed point based factorial:

#+BEGIN_SRC haskell
let fix f :=
      let x := f x in x;
    fact rec n :=
       if eq n 0
       then 1
       else mult n (rec (minus n 1))
in fix fact 4
#+END_SRC

** Implementation

In this section I will briefly describe how my idea works.

Input ~String~ is turned into ~AST~ via [[http://hackage.haskell.org/package/megaparsec-7.0.1][Megaparsec]]. ~AST~ is the almost exact context-free representation of code — it is completely desugared and it's purpose is just to "read" the input without going deeper into it's meaning.

Next, ~AST~ is converted into ~Expr~ by ~processAST~ function. The process is pretty trivial — it will do job like replacing ~f a := \x y -> q~ with ~f := \a -> \x -> \y -> q~. Main reason for this layer is to resolve conflict between nice syntax and simplicity of evaluation.

Then the ~Expr~ is thrown in front of the Type Correctness Court — the typechecker. It uses the [[https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Algorithm_W][Algorithm W]] for type inference in Hindley–Milner type system, which allows having nice polymorphic types and optional hints from programmer.

After typecheck succeeds ~Expr~ is passed into ~Evaluator~ which carries namespace, dataspace and handles runtime errors. Namespace lives in ~Reader~ monad as it is scope local — it maps names into data indices. Dataspace however is under constant modification, so it is moved into ~State~ — it's task is to map data indices into actual data.

** Special thanks

Special thanks to Wojciech Jabłoński who showed me neccessary algorithms and solutions without which writing this would be a total hell.
