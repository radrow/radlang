% Created 2019-04-11 czw 16:52
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Radosław Rowicki}
\date{\today}
\title{Radlang programming language}
\hypersetup{
 pdfauthor={Radosław Rowicki},
 pdftitle={Radlang programming language},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.2.2)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{About}
\label{sec:org7422b0f}

Radlang is a pure functional programming language that targets to inherit most of Haskell's features. It supports higher order polymorphic algebraic datatypes, full type inference, typeclasses (known as intefaces) and rich syntax. The evaluation order is lazy by default, however the user is allowed to manage it to some extent.

In the future it will probably support memory management via automated garbage collection and have read-eval-print loop.

\section{Syntax}
\label{sec:org5386b3a}


\begin{verbatim}

kind ::= "Type" | kind "->" kind | "(" kind ")"

general_typename ::= "~" upper_case_string

type ::= general_typename (* type var *)
       | upper_case_string (* rigid type *)
       | type "->" type (* function type *)
       | type {type}+ (* type application *)
       | "(" type ")"

predicate ::= type "is" upper_case_string

qualified_type ::= [predicate {"," predicate}* "|"] type

literal ::= signed number
          | "'" character "'"
          | "\"" {escaped_character}* "\""

pattern ::= lower_case_string (* var name *)
          | "_" (* wildcard *)
          | lower_case_string "@" pattern (* "as" pattern *)
          | literal
          | upper_case_string {pattern}*
          | "(" pattern ")"

typedecl ::= lower_case_string ":" qualified_type

datadef ::= lower_case_string [pattern] ":=" expr

binding ::= datadef | typedecl

for_unit ::= pattern "<-" expr | expr

expr ::= lower_case_string (* variable *)
       | upper_case_string (* constructor *)
       | literal
       | expr {expr}+ (* application *)
       | "let" binding {"|" assignment}* "in" expr
       | {"if" expr "then" expr}+ "else" expr (* multi way if *)
       | "\ " pattern "->" expr (* lambda *)
       | "match" expr "with" {"|" pattern "->" expr}+ (* pattern match *)
       | "for" "{" [for_unit {"|" for_unit}*] "}" expr (* monadic for comprehension *)
       | "[" [expr {"," expr}*] "]" (* list sugar *)
       | "(" expr ")"

constructor_def ::= upper_case_string {type}*

newtype ::= "newtype" upper_case_string {"(" general_typename ":" kind ")"}* ":=" {constructor_def}*

interface ::= 
  "interface" upper_case_string "(" general_typename ":" kind ")"
    ["implies" upper_case_string {upper_case_string}*] (* superclasses *)
    "{"
     {typedecl ";;"}*
    "}"

impl ::= (* interface implementation *)
  "impl" qual_type "for" upper_case_string
   "{"
    {datadef ";;"}*
   "}"

program ::= {(newtype | typedecl | datadef | interface | impl) ";;"}*

\end{verbatim}

\section{Overview}
\label{sec:org6e20f71}

\subsection{Basic definitions and examples}
\label{sec:org1d1b6fc}

The program is a set of data definitions, type declarations, newtype definitions, interface declarations and implementations of the interfaces. The infix operators probably won't be supported. Program must contain `main` definition of any type – it will be the point where the evaluation starts. `main` will be deeply forced and will never contain any unevaluated thunk.

\subsubsection{Hello world}
\label{sec:org28dad7b}

\begin{verbatim}
main := "hello world";;
\end{verbatim}

\subsubsection{Use of toplevel function and \texttt{if} statement}
\label{sec:org4dddb03}

\begin{verbatim}
identity x := x;;

main := if identity True then identity False else False;;
\end{verbatim}

\subsubsection{Type declaration and pattern matching}
\label{sec:org21a1421}

\begin{verbatim}
fun : Int -> Bool;;
fun 0 := True;;
fun x = match x with
  | 4 -> False
  | _ -> eqInt x 7
;;
\end{verbatim}

Note that no variable may appear twice in a single set of patterns. Differing numbers of function arguments are not supported, so following code \textbf{\textbf{won't}} pass the syntax check:

\begin{verbatim}
f x := 1;;
f := const 2;;
\end{verbatim}

\subsubsection{For comprehension}
\label{sec:orgb414477}
This construction uses implicitly \texttt{bind} function like in Haskell's \texttt{do} notation:

\begin{verbatim}
main := for 
  { x <- x_m
  | y <- y_m
  | guard (gtInt y x)
  } unit (plusInt x y)
;;
\end{verbatim}

\subsubsection{Type declarations and data definitions}
\label{sec:org9767133}

\begin{verbatim}
x : Int;;

notEq : ~A is Eq -> ~A -> ~A -> Bool;;

mplus : ~A is Semigroup, ~M is Monad | ~M ~A -> ~M ~A -> ~M ~A;;
\end{verbatim}

In opposite to Haskell one may define variable without any value. To do so, the programmer must declare its type only:

\begin{verbatim}
bot : ~A;;

bot_int : Int;;
\end{verbatim}

\subsection{New type definition}
\label{sec:org0b039a0}

Types can be defined in casual ADT terms, however the programmer must explicitly provide kind annotation for every type-argument:

\begin{verbatim}
newtype Bool := True | False;;

newtype List (~A : Type) := Nil | Cons ~A (List ~A);;

newtype StateT (~S : Type) (~M : Type -> Type) (~A : Type) :=
  StateT (~S -> ~M (Pair ~S ~A))
\end{verbatim}

Such data may be deeply pattern matched:

\begin{verbatim}
f l := match l with
  | Nil -> 0
  | Cons 3 (Cons x _) -> 1
  | _ -> 2
\end{verbatim}

\subsection{Laziness management}
\label{sec:orgeaf1cef}

Every value is treatet lazily, that means following code

\begin{verbatim}
bot : ~A;;

main := (\a b -> a) 3 bot;;
\end{verbatim}

will successfully return 3. However there are two built in functions that are able to interfere this behavior:

\begin{itemize}
\item \texttt{force : \textasciitilde{}A -> \textasciitilde{}B -> \textasciitilde{}B} – that forces its first argument to WHNF and returns the second (just like Haskell's \texttt{seq})
\item \texttt{deepForce : \textasciitilde{}A -> \textasciitilde{}B -> \textasciitilde{}B} – that deeply forces all possible parts of the first argument
\end{itemize}

\texttt{main} function will always implicitly call \texttt{deepForce} on its value. Examples:

\begin{verbatim}
test (Cons _ _) := True;;
test _ := False;;
bot : ~Any;;

main0 := test Nil;; -- False

main1 := test bot;; -- out of domain error

main2 := test (Cons bot bot);; -- True

main3 := force bot True;; -- out of domain error

main5 := let x := Cons bot bot in True;; -- True

main4 := force (Const bot bot) True;; -- True

main6 := deepForce (Cons bot bot) True;; -- out of domain error
\end{verbatim}

\subsection{Interfaces}
\label{sec:org0bfe5c8}

Interfaces are technically same thing as typeclasses or traits in other languages. They may inherit each other as long as they do not form cycles (that would be a true deviation).

One of the most fancy features of this system is that implementation may provide definitions for any upper interface in an inheriting interface:

\begin{verbatim}
interface Semigroup (~S : Type) {
  plus : ~S -> ~S -> ~S;;
};;

interface Monoid (~S : Type) implies Semigroup {
  null : ~S;;
};;

impl Int for Monoid {
  plus := plusInt;;
  null := 0;;
};;
\end{verbatim}

\subsection{Stacktrace}
\label{sec:orga010fc7}

Running program will keep two different stacktraces to ease debugging. The stacktraces will appear on every runtime error.

One may wonder what is the reason to have two of them. The answer is simple – laziness. Consider following code:

\begin{verbatim}
main :=
  let x := f 1
  in g x;;

f x := divInt x 0;; -- division by zero!

g x := deepForce x x;;
\end{verbatim}

The program will surely return an error, but what should its stacktrace be? In strict languages it would be obvious – \texttt{[main, f, divInt]}, because this is the place where runtime failed. However, because Radlang is lazy the error will be thrown at \texttt{[deepForce, divInt]}. So which stacktrace is correct? Being prepared for situation where the user can't decide, I provide both of them – first one is called "definition stacktrace", and the second one is "evaluation stacktrace".

What happened to the \texttt{g} function in the evaluation stacktrace? The answer is simple – it is just not present there. \texttt{g} was fully evaluated and returned thunk that contains \texttt{deepForce x x} with \texttt{x} assigned to \texttt{f 1}. The error was actually thrown out of the main function so it is not mentioned either!

\section{What may be included, but doesn't have to}
\label{sec:orgb8f59e1}

\begin{itemize}
\item infix operators
\item explicitly typed GADTs
\item garbage collection
\item type aliasses
\item REPL
\item tensorflow bindings
\end{itemize}

\section{MIMUW course grade expectation}
\label{sec:org367b2a5}

I expect to get maximum number of points if I finish all the features declared here (excluding "what may be included" section). Typeclasses are quite complicated in terms of typechecking and semantics, so in my opinion I would deserve it. I am going to take care over the syntax and in the end my target is to provide software that could be used for educational purposes.
\end{document}